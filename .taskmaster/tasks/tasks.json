{
  "master": {
    "tasks": [
      {
        "id": 11,
        "title": "[BFS-4] signing-service Multicall3 배치 전송 기능 구현",
        "description": "ERC20 토큰 배치 전송을 위한 Multicall3 통합 기능 구현",
        "jiraKey": "BFS-4",
        "details": "Multicall3 컨트랙트 주소 설정 (Polygon: 0xcA11bde05977b3631167028862bE2a173976CA11), MulticallService 클래스 구현으로 여러 ERC20 전송을 하나의 트랜잭션으로 배치 처리, TransactionSigner에 signBatchTransaction() 메서드 추가, WithdrawalRequest 모델에 type 필드 추가 ('SINGLE' | 'BATCH'), ABI 인코딩 및 calldata 생성 로직 구현, 배치 크기 최적화 (가스 한도 내에서 최대 전송 수 계산)",
        "testStrategy": "Multicall3 컨트랙트 호출 테스트, 배치 전송 가스 계산 정확성 검증, 단일 vs 배치 전송 성능 비교 테스트, 최대 배치 크기 한계 테스트, 실패 시나리오 (가스 부족, 잘못된 토큰 주소) 테스트",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "[BFS-2] Polygon Multicall3 컨트랙트 주소 설정",
            "description": "Polygon 네트워크의 Multicall3 컨트랙트 주소를 환경 설정에 추가하고 네트워크별 구성 관리",
            "jiraKey": "BFS-2",
            "dependencies": [],
            "details": "환경 변수에 Multicall3 컨트랙트 주소 (0xcA11bde05977b3631167028862bE2a173976CA11) 추가, 네트워크별 주소 매핑 구성, 환경 설정 검증 로직 구현\n<info added on 2025-07-21T13:56:54.550Z>\nPOLYGON_MULTICALL3_ADDRESS 환경 변수를 .env.sample에 추가 완료, config/index.ts에서 환경 변수 읽기와 주소 검증 로직이 구현됨, config/networks.ts 파일을 새로 생성하여 Amoy 테스트넷과 Polygon 메인넷 모두에 대해 Multicall3 주소 0xcA11bde05977b3631167028862bE2a173976CA11 매핑을 구성함\n</info added on 2025-07-21T13:56:54.550Z>\n<info added on 2025-07-21T14:20:16.702Z>\n기존 환경변수 기반 Multicall3 설정을 제거하고 중앙집중식 관리로 전환 완료. packages/shared/src/config/chains.config.json에 polygon, ethereum, bsc 체인 모두에 대해 multicall3Address 속성 추가됨. ChainProvider 클래스에 getMulticall3Address(chainType: ChainType) 메서드 구현하여 체인별 Multicall3 주소 조회 기능 제공. signing-service의 config/networks.ts와 환경변수 POLYGON_MULTICALL3_ADDRESS 설정 제거하여 중복 제거 및 일관된 설정 관리 달성.\n</info added on 2025-07-21T14:20:16.702Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "[BFS-3] MulticallService 클래스 구현",
            "description": "여러 ERC20 전송을 하나의 트랜잭션으로 배치 처리하는 MulticallService 핵심 클래스 개발",
            "jiraKey": "BFS-3",
            "dependencies": [
              "11.1"
            ],
            "details": "MulticallService 클래스 구조 설계, 배치 전송 요청 처리 메서드, Multicall3 컨트랙트와의 인터페이스 구현, 에러 핸들링 로직 추가\n<info added on 2025-07-21T14:35:33.022Z>\nMulticallService 클래스 구현이 완료되었습니다. apps/signing-service/src/services/multicall.service.ts 파일에 다음 주요 메서드들이 구현되었습니다: prepareBatchTransfer (배치 전송 준비), encodeBatchTransaction (트랜잭션 인코딩), validateBatch (배치 검증), getOptimalBatchSize (최적 배치 크기 계산). ChainProvider를 통해 Multicall3 컨트랙트 주소를 동적으로 가져오도록 설계하였으며, apps/signing-service/src/services/__tests__/multicall.service.test.ts 테스트 파일을 작성하여 모든 기능에 대한 검증을 완료했습니다.\n</info added on 2025-07-21T14:35:33.022Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "[BFS-14] ABI 인코딩 및 calldata 생성 로직 구현",
            "description": "ERC20 전송을 위한 ABI 인코딩과 Multicall3용 calldata 생성 로직 개발",
            "jiraKey": "BFS-14",
            "dependencies": [
              "11.2"
            ],
            "details": "ERC20 transfer 함수 ABI 인코딩, Multicall3 aggregate 함수를 위한 calldata 배열 생성, 인코딩 정확성 검증, 바이트 데이터 최적화",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "[BFS-15] 배치 크기 최적화 로직 구현",
            "description": "가스 한도 내에서 최대 전송 수를 계산하는 배치 크기 최적화 기능 개발",
            "jiraKey": "BFS-15",
            "dependencies": [
              "11.3"
            ],
            "details": "가스 사용량 추정 로직, 블록 가스 한도 대비 최적 배치 크기 계산, 동적 배치 크기 조정 알고리즘, 가스비 효율성 분석",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "[BFS-16] TransactionSigner 확장 및 배치 서명 기능 추가",
            "description": "기존 TransactionSigner에 signBatchTransaction() 메서드를 추가하여 배치 트랜잭션 서명 지원",
            "jiraKey": "BFS-16",
            "dependencies": [
              "11.4"
            ],
            "details": "signBatchTransaction() 메서드 구현, 단일 트랜잭션과 배치 트랜잭션 서명 로직 통합, nonce 관리 개선, 서명 검증 로직 추가",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "[BFS-17] 데이터 모델 업데이트 및 통합 테스트",
            "description": "WithdrawalRequest 모델에 type 필드 추가 및 전체 Multicall3 기능 통합 테스트 수행",
            "jiraKey": "BFS-17",
            "dependencies": [
              "11.5"
            ],
            "details": "WithdrawalRequest 모델에 type: 'SINGLE' | 'BATCH' 필드 추가, 데이터베이스 스키마 업데이트, 단일/배치 전송 통합 테스트, 성능 비교 테스트 수행",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "[BFS-18] Multicall3 컨트랙트 주소 설정 및 ChainProvider 확장",
            "description": "Polygon 메인넷 및 테스트넷에 대한 Multicall3 컨트랙트 주소 설정 및 ChainProvider에서 주소 조회 기능 구현",
            "jiraKey": "BFS-18",
            "dependencies": [],
            "details": "Polygon 메인넷(0xcA11bde05977b3631167028862bE2a173976CA11) 및 Amoy 테스트넷 Multicall3 주소 추가, ChainProvider.getMulticallAddress() 메서드 구현, 네트워크별 주소 매핑 로직 추가, 환경 변수 기반 네트워크 선택 지원",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "[BFS-19] MulticallService 클래스 리팩토링 및 확장",
            "description": "기존 MulticallService를 확장하여 실제 배치 전송 기능 완성 및 성능 최적화",
            "jiraKey": "BFS-19",
            "dependencies": [
              "11.7"
            ],
            "details": "MulticallService에서 실제 Multicall3 컨트랙트 호출 로직 구현, 배치 전송 결과 파싱 및 처리, 가스 추정 로직 개선, aggregate3 메서드를 사용한 배치 호출 구현, 실패한 전송 건 개별 처리 로직 추가",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "[BFS-20] ERC-20 ABI 인코딩 및 calldata 생성 로직 구현",
            "description": "ERC-20 transfer 메서드를 위한 ABI 인코딩 로직 및 Multicall3용 calldata 생성 기능 구현",
            "jiraKey": "BFS-20",
            "dependencies": [
              "11.8"
            ],
            "details": "Ethers.js Interface를 사용한 transfer 메서드 인코딩, Multicall3.Call 구조체 생성 로직, 다중 토큰 전송을 위한 calldata 배열 생성, 각 전송 건별 target, allowFailure, callData 설정, ABI 인코딩 오류 핸들링",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "[BFS-21] 배치 크기 최적화 및 가스 계산 로직",
            "description": "가스 한도 내에서 최적의 배치 크기를 계산하고 동적으로 조정하는 기능 구현",
            "jiraKey": "BFS-21",
            "dependencies": [
              "11.9"
            ],
            "details": "가스 한도 기반 최대 배치 크기 계산 알고리즘, 토큰별 전송 비용 추정, 배치 오버헤드 고려한 최적화, 동적 배치 분할 로직, Polygon 네트워크 가스 특성 반영, 배치 크기별 성능 테스트 및 벤치마킹\n<info added on 2025-07-22T15:13:46.918Z>\n구현 완료: Polygon 네트워크 기반 가스 최적화 시스템 - 30M 가스 한도와 75% 안전 마진을 적용한 동적 배치 분할 알고리즘 구현, 토큰별 가스 비용 학습 캐싱 시스템 도입으로 실시간 비용 예측 정확도 향상, 배치 크기에 따른 점감 가스 비용 계산 로직으로 배치 효율성 극대화, 향상된 fallback 가스 추정 메커니즘으로 네트워크 혼잡 상황 대응 강화, 모든 단위 테스트 및 통합 테스트 통과 확인\n</info added on 2025-07-22T15:13:46.918Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 11,
            "title": "[BFS-22] TransactionSigner 배치 전송 기능 확장",
            "description": "TransactionSigner 클래스에 배치 트랜잭션 서명 기능 추가 및 기존 단일 전송과의 통합",
            "jiraKey": "BFS-22",
            "dependencies": [
              "11.10"
            ],
            "details": "signBatchTransaction() 메서드 구현, 배치 트랜잭션 가스 추정 로직, EIP-1559 트랜잭션 타입 지원, 배치와 단일 전송 구분 로직, nonce 관리 개선, 트랜잭션 서명 실패 시 개별 전송으로 fallback 메커니즘\n<info added on 2025-07-22T15:20:23.097Z>\nBFS-22 구현 완료. signBatchTransaction() 메서드와 signBatchTransactionWithSplitting() 메서드 추가하여 Multicall3 배치 전송 서명 지원. getGasPrice() 메서드 추출로 코드 중복 제거. 단일 및 분할 배치, 검증 실패 처리, 가스 추정, Redis 연결 에러 처리, 대용량 배치 시나리오 등에 대한 포괄적인 테스트 커버리지 구현. MulticallService와의 통합으로 배치 준비 및 인코딩 지원. Polygon 네트워크에서 EIP-1559 트랜잭션 지원. 배치 분할 시 순차적 nonce 관리 구현. 모든 테스트, 린트 검사, 타입 검사 통과 확인.\n</info added on 2025-07-22T15:20:23.097Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 12,
            "title": "[BFS-23] WithdrawalRequest 모델 업데이트 및 배치 처리 지원",
            "description": "WithdrawalRequest 모델에 배치 전송 타입 필드 추가 및 관련 데이터베이스 스키마 업데이트",
            "jiraKey": "BFS-23",
            "dependencies": [
              "11.11"
            ],
            "details": "WithdrawalRequest에 type 필드 추가 ('SINGLE' | 'BATCH'), batchId 필드 추가로 배치 그룹 관리, Prisma 스키마 업데이트, 기존 레코드와의 호환성 보장, 배치 전송 상태 추적 로직, 배치 내 개별 전송 상태 관리 기능",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 13,
            "title": "[BFS-24] Multicall3 컨트랙트 주소 및 ABI 구성 설정",
            "description": "Polygon 네트워크용 Multicall3 컨트랙트 주소와 ABI 정의를 설정하고 네트워크별 구성 관리",
            "jiraKey": "BFS-24",
            "dependencies": [],
            "details": "Polygon 메인넷 및 테스트넷용 Multicall3 컨트랙트 주소 (0xcA11bde05977b3631167028862bE2a173976CA11) 설정, Multicall3 ABI 정의, 네트워크별 설정 파일 구성, 컨트랙트 주소 검증 로직",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 14,
            "title": "[BFS-25] MulticallService 클래스 기본 구조 구현",
            "description": "배치 전송을 위한 MulticallService 클래스의 기본 구조와 의존성 주입 설정",
            "jiraKey": "BFS-25",
            "dependencies": [],
            "details": "MulticallService 클래스 생성, Ethers.js Provider 및 Contract 인스턴스 초기화, 의존성 주입을 위한 생성자 설정, 기본 인터페이스 및 타입 정의, 에러 처리를 위한 기본 구조",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 15,
            "title": "[BFS-26] ERC20 transfer ABI 인코딩 로직 구현",
            "description": "ERC20 토큰 전송을 위한 ABI 인코딩과 calldata 생성 기능 개발",
            "jiraKey": "BFS-26",
            "dependencies": [],
            "details": "ERC20 transfer 함수 ABI 인코딩, 토큰 주소/수신자/금액 파라미터 검증, calldata 바이트 배열 생성, 인코딩 정확성 검증 로직, 인코딩 에러 핸들링",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 16,
            "title": "[BFS-27] 배치 크기 최적화 및 가스 계산 로직",
            "description": "가스 한도 내에서 최적의 배치 크기를 계산하고 가스비 추정 기능 구현",
            "jiraKey": "BFS-27",
            "dependencies": [],
            "details": "배치 전송당 가스 소모량 추정, 가스 한도 기반 최대 배치 크기 계산, 동적 배치 크기 조정 알고리즘, 가스비 최적화 로직, 배치 분할 전략 구현",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 17,
            "title": "[BFS-28] TransactionSigner에 배치 전송 메서드 확장",
            "description": "기존 TransactionSigner 클래스에 signBatchTransaction() 메서드 추가 및 통합",
            "jiraKey": "BFS-28",
            "dependencies": [],
            "details": "signBatchTransaction() 메서드 구현, Multicall3 트랜잭션 구조 생성, 기존 단일 전송과 배치 전송 로직 통합, 트랜잭션 타입별 분기 처리, 서명 검증 로직 확장\n<info added on 2025-07-22T08:36:49.185Z>\n실제 구현 완료: signBatchTransaction() 메서드가 TransactionSigner 클래스에 성공적으로 추가됨. BatchSigningRequest를 매개변수로 받아 여러 전송을 검증하고, MulticallService를 사용하여 배치를 준비한 후 단일 Multicall3 트랜잭션으로 서명하는 기능이 정상 동작함. SigningWorker에도 MulticallService 종속성 주입이 완료되었으며, 새로운 종속성을 포함하도록 모든 테스트가 수정됨.\n</info added on 2025-07-22T08:36:49.185Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 18,
            "title": "[BFS-29] WithdrawalRequest 모델 및 데이터베이스 스키마 업데이트",
            "description": "배치 전송 지원을 위한 모델 확장과 관련 데이터베이스 스키마 변경",
            "jiraKey": "BFS-29",
            "dependencies": [],
            "details": "WithdrawalRequest 모델에 type 필드 추가 ('SINGLE' | 'BATCH'), 배치 전송 관련 추가 필드 정의, Prisma 스키마 업데이트, 기존 데이터 호환성 보장, 마이그레이션 스크립트 작성\n<info added on 2025-07-22T13:41:16.651Z>\n새로운 구조: BatchTransaction 테이블을 생성하여 배치 메타데이터 저장 (batchId, totalAmount, tokenAddress, status, createdAt), WithdrawalRequest에 batchId 필드 추가하여 배치와 개별 요청 연결, SignedTransaction은 개별 트랜잭션 처리용으로 유지, 동적 배치 처리를 위한 관계형 구조 설계, 배치 상태 관리 및 추적 기능, 기존 단일 전송과의 하위 호환성 보장\n</info added on 2025-07-22T13:41:16.651Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 19,
            "title": "[BFS-30] SigningWorker 동적 배치 처리 로직 구현",
            "description": "큐 메시지를 분석하여 배치/단일 처리를 동적으로 결정하고 Multicall3 컨트랙트를 활용한 배치 처리 최적화 구현 [Updated: 2025. 7. 22.] [Updated: 2025. 7. 22.] [Updated: 2025. 7. 22.]",
            "jiraKey": "BFS-30",
            "status": "done",
            "dependencies": [
              "11.18"
            ],
            "details": "SigningWorker 클래스의 processBatch() 메서드 리팩토링으로 동적 배치 처리 로직 구현:\n\n1. shouldUseBatchProcessing() 메서드 구현\n   - 환경 변수 ENABLE_BATCH_PROCESSING 체크 (기본값: true)\n   - 큐 메시지 수가 MIN_BATCH_SIZE (기본: 5) 이상인지 확인\n   - 동일 토큰 주소의 트랜잭션이 BATCH_THRESHOLD (기본: 3) 이상인지 검증\n   - 예상 가스 절약률이 MIN_GAS_SAVINGS_PERCENT (기본: 20%) 이상인지 계산\n\n2. groupByToken() 메서드 구현\n   ```typescript\n   private groupByToken(messages: Message<WithdrawalMessage>[]): Map<string, Message<WithdrawalMessage>[]> {\n     return messages.reduce((groups, message) => {\n       const tokenAddress = message.body.tokenAddress.toLowerCase();\n       if (!groups.has(tokenAddress)) {\n         groups.set(tokenAddress, []);\n       }\n       groups.get(tokenAddress)!.push(message);\n       return groups;\n     }, new Map());\n   }\n   ```\n\n3. calculateGasSavings() 메서드 구현\n   - 개별 처리 예상 가스: count * SINGLE_TX_GAS_ESTIMATE\n   - 배치 처리 예상 가스: BATCH_BASE_GAS + (count * BATCH_PER_TX_GAS)\n   - 절약률 계산: ((개별 - 배치) / 개별) * 100\n\n4. processBatch() 메서드 수정\n   ```typescript\n   async processBatch(messages: Message<WithdrawalMessage>[]): Promise<void> {\n     if (await this.shouldUseBatchProcessing(messages)) {\n       const tokenGroups = this.groupByToken(messages);\n       \n       for (const [tokenAddress, groupMessages] of tokenGroups) {\n         if (groupMessages.length >= this.config.BATCH_THRESHOLD) {\n           await this.processBatchGroup(tokenAddress, groupMessages);\n         } else {\n           await this.processSingleTransactions(groupMessages);\n         }\n       }\n     } else {\n       await this.processSingleTransactions(messages);\n     }\n   }\n   ```\n\n5. processBatchGroup() 메서드 구현\n   - BatchTransaction 엔티티 생성 (status: 'pending')\n   - 개별 Transaction 레코드 생성 및 batchId 연결\n   - Multicall3 컨트랙트 호출 데이터 생성\n   - 배치 트랜잭션 서명 및 전송\n   - 결과에 따른 상태 업데이트\n\n6. 환경 변수 설정\n   ```env\n   ENABLE_BATCH_PROCESSING=true\n   MIN_BATCH_SIZE=5\n   BATCH_THRESHOLD=3\n   MIN_GAS_SAVINGS_PERCENT=20\n   SINGLE_TX_GAS_ESTIMATE=65000\n   BATCH_BASE_GAS=100000\n   BATCH_PER_TX_GAS=25000\n   ```\n\n7. 로깅 및 메트릭 추가\n   - 배치 처리 결정 로직 로깅\n   - 가스 절약 예상치 로깅\n   - 배치 처리 성공/실패 메트릭\n<info added on 2025-07-22T14:01:02.619Z>\n종속성 업데이트: 이전 종속성인 11, 11.3, 11.4에서 11.18 (WithdrawalRequest 모델 및 데이터베이스 스키마 업데이트)로 변경. 11.11, 11.11.3, 11.11.4는 존재하지 않는 태스크였으므로 제거됨.\n</info added on 2025-07-22T14:01:02.619Z>\n<info added on 2025-07-22T14:09:36.960Z>\nJira 이슈 키: BFS-30\n</info added on 2025-07-22T14:09:36.960Z>\n<info added on 2025-07-22T14:13:27.897Z>\n제목을 \"[BFS-30] SigningWorker 동적 배치 처리 로직 구현\"으로 업데이트함. Jira 이슈 키 BFS-30이 제목에 접두사로 추가됨.\n</info added on 2025-07-22T14:13:27.897Z>\n<info added on 2025-07-23T02:11:54.817Z>\n코드베이스 분석 결과:\n- SigningWorker가 BaseWorker를 상속받아 processBatch() 메서드 사용\n- 현재는 개별 트랜잭션 처리만 구현되어 있음\n- MulticallService가 이미 구현되어 배치 처리 기능 제공\n- BatchTransaction 모델이 Prisma 스키마에 정의됨\n- Config 클래스를 통한 환경 변수 관리 구조 확인\n\n구현 준비사항:\n- BaseWorker의 기존 processBatch() 메서드를 오버라이드하여 동적 배치 처리 로직 추가\n- MulticallService와의 연동을 통한 실제 배치 트랜잭션 실행\n- Config 클래스에 배치 처리 관련 환경 변수 추가 필요\n- BatchTransaction 모델을 활용한 배치 상태 관리 구현\n</info added on 2025-07-23T02:11:54.817Z>\n<info added on 2025-07-23T02:19:48.749Z>\n구현 완료 - 2025년 7월 23일:\n\n✅ 주요 구현 사항:\n- shouldUseBatchProcessing(): 환경변수(ENABLE_BATCH_PROCESSING), 메시지 수(MIN_BATCH_SIZE), 토큰 그룹 크기(BATCH_THRESHOLD), 가스 절약률(MIN_GAS_SAVINGS_PERCENT) 기반 동적 판단 로직 완성\n- groupByToken(): 토큰 주소별 메시지 그룹화 메서드 구현\n- calculateGasSavings(): 배치 vs 개별 처리 가스 비용 비교 및 절약률 계산 로직 구현\n- processBatch() 메서드 오버라이드: BaseWorker 상속하여 배치/개별 처리 분기 로직 완성\n- processBatchTransactions(): 토큰 그룹별 배치 처리 실행 메서드 구현\n- processBatchGroup(): BatchTransaction 엔티티 생성, Multicall3 컨트랙트 연동, 트랜잭션 서명 및 상태 관리 완성\n\n✅ 검증 완료:\n- 모든 단위 테스트 작성 및 통과\n- TypeScript 타입체크 통과\n- ESLint 코드 품질 검사 통과\n- MulticallService와의 연동 검증 완료\n\n구현된 기능으로 동적 배치 처리 최적화를 통한 가스 비용 절약 및 트랜잭션 처리 효율성 향상 달성.\n</info added on 2025-07-23T02:19:48.749Z>",
            "testStrategy": "1. shouldUseBatchProcessing() 단위 테스트\n   - 환경 변수가 false일 때 항상 false 반환 확인\n   - 메시지 수가 MIN_BATCH_SIZE 미만일 때 false 반환 확인\n   - 동일 토큰 그룹이 BATCH_THRESHOLD 미만일 때 false 반환 확인\n   - 가스 절약률이 MIN_GAS_SAVINGS_PERCENT 미만일 때 false 반환 확인\n   - 모든 조건 충족 시 true 반환 확인\n\n2. groupByToken() 단위 테스트\n   - 빈 메시지 배열 처리 확인\n   - 단일 토큰 주소 그룹핑 확인\n   - 여러 토큰 주소 정확한 그룹핑 확인\n   - 대소문자 정규화 확인 (0xABC와 0xabc가 같은 그룹)\n\n3. calculateGasSavings() 단위 테스트\n   - 다양한 트랜잭션 수에 대한 절약률 계산 정확성\n   - 음수 절약률 처리 (배치가 더 비쌀 때)\n   - 경계값 테스트 (1개, 2개, 임계값 근처)\n\n4. processBatch() 통합 테스트\n   - 배치 처리 비활성화 시 모든 트랜잭션 개별 처리 확인\n   - 메시지 수 부족 시 개별 처리 확인\n   - 동일 토큰 그룹이 임계값 이상일 때만 배치 처리 확인\n   - 혼합 시나리오 테스트 (일부는 배치, 일부는 개별)\n\n5. processBatchGroup() 통합 테스트\n   - BatchTransaction 레코드 생성 확인\n   - 개별 Transaction 레코드의 batchId 연결 확인\n   - Multicall3 호출 데이터 정확성 검증\n   - 성공/실패 시 상태 업데이트 확인\n\n6. E2E 테스트\n   - 실제 큐 메시지로 전체 플로우 테스트\n   - 배치 처리 후 블록체인 상태 검증\n   - 가스 사용량 실제 측정 및 예상치 비교"
          }
        ]
      },
      {
        "id": 12,
        "title": "[BFS-5] tx-broadcaster 서비스 구현",
        "description": "서명된 트랜잭션을 Polygon 네트워크에 브로드캐스트하는 서비스 개발",
        "jiraKey": "BFS-5",
        "details": "Nx를 사용하여 tx-broadcaster 앱 생성 (nx g @nx/node:app tx-broadcaster), signed-tx-queue에서 SQS 메시지 폴링, 데이터베이스에서 서명된 트랜잭션 조회, Ethers.js v6를 사용하여 Polygon 네트워크 브로드캐스트, 트랜잭션 상태를 SIGNED → BROADCASTED → CONFIRMED로 업데이트, nonce 충돌 감지 및 DLQ 처리, RPC 실패 시 지수 백오프 재시도 로직, 브로드캐스트 성공 후 tx-monitor-queue에 메시지 전송",
        "testStrategy": "정상 브로드캐스트 플로우 테스트, nonce 충돌 시나리오 테스트, RPC 실패 및 재시도 테스트, 재시도 한도 초과 시 DLQ 처리 테스트, 단일/배치 트랜잭션 브로드캐스트 테스트",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "[BFS-6] tx-monitor 서비스 구현",
        "description": "브로드캐스트된 트랜잭션의 상태를 추적하고 확인하는 모니터링 서비스 개발",
        "jiraKey": "BFS-6",
        "details": "Nx를 사용하여 tx-monitor 앱 생성, tx-monitor-queue에서 브로드캐스트된 트랜잭션 수신, Polygon 네트워크에서 트랜잭션 상태 및 confirmations 수 추적, 12 confirmations 달성 시 CONFIRMED 상태로 업데이트, 실패한 트랜잭션 감지 및 알림, 장기간 pending 상태인 트랜잭션에 대한 가스비 인상 재시도 트리거, Redis를 사용한 모니터링 상태 캐싱으로 성능 최적화, 배치 트랜잭션의 경우 모든 개별 전송 확인",
        "testStrategy": "트랜잭션 확인 수 추적 테스트, 성공/실패 트랜잭션 상태 업데이트 테스트, 장기간 pending 트랜잭션 감지 테스트, 가스비 인상 재시도 로직 테스트, 배치 트랜잭션 모니터링 테스트",
        "priority": "high",
        "dependencies": [
          12
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "[BFS-7] DLQ(Dead Letter Queue) 핸들러 구현",
        "description": "실패한 메시지 처리 및 복구를 위한 DLQ 핸들러 서비스 개발",
        "jiraKey": "BFS-7",
        "details": "각 큐(tx-request-queue, signed-tx-queue)에 대한 DLQ 설정, 실패 메시지 분류 로직 (영구적 실패 vs 일시적 실패), 재시도 자격 판단 알고리즘 (시간 기반, 실패 유형 기반), 재시도 가능한 메시지를 원본 큐로 재전송, 수동 개입이 필요한 메시지에 대한 알림 시스템, DLQ 메시지 조회 및 관리 API, 실패 패턴 분석 및 로깅",
        "testStrategy": "영구적 vs 일시적 실패 분류 테스트, 재시도 로직 검증 테스트, DLQ 메시지 복구 테스트, 수동 개입 알림 테스트, 실패 패턴 분석 테스트",
        "priority": "medium",
        "dependencies": [
          12
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "[BFS-8] signing-service 잔액 검증 기능 구현",
        "description": "트랜잭션 서명 전 실제 토큰 잔액 및 가스 수수료 검증 기능 추가",
        "jiraKey": "BFS-8",
        "details": "ERC-20 토큰 잔액 확인을 위한 BalanceService 구현, Ethers.js를 사용하여 토큰 컨트랙트 잔액 조회, 네이티브 토큰(MATIC) 잔액 확인, 가스 수수료 계산 및 검증 (EIP-1559 기준), 출금 한도 확인 로직, Redis를 활용한 잔액 정보 캐싱 (30초 TTL), 배치 전송의 경우 총 출금 금액과 잔액 비교, 잔액 부족 시 적절한 에러 응답",
        "testStrategy": "토큰 잔액 조회 정확성 테스트, 가스 수수료 계산 테스트, 잔액 부족 시나리오 테스트, 캐싱 동작 검증 테스트, 배치 전송 잔액 검증 테스트",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "[BFS-9] Admin API 인증 시스템 구현",
        "description": "JWT 기반 인증 및 역할 기반 접근 제어를 포함한 Admin API 시스템 구축",
        "jiraKey": "BFS-9",
        "details": "User 모델 및 Prisma 스키마 추가, bcrypt를 사용한 패스워드 해싱, JWT 토큰 생성/검증 미들웨어, 역할 기반 접근 제어 (USER, ADMIN, SUPER_ADMIN), 인증 엔드포인트 구현 (POST /auth/register, POST /auth/login, POST /auth/refresh), API Rate Limiting (IP 기반: 60/분, 사용자 기반: 100/분), 토큰 갱신 로직, 세션 관리 및 보안 헤더 설정",
        "testStrategy": "사용자 등록/로그인 플로우 테스트, JWT 토큰 검증 테스트, 역할 기반 접근 제어 테스트, Rate Limiting 동작 테스트, 토큰 갱신 로직 테스트",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "[BFS-10] Admin API 관리 기능 구현",
        "description": "트랜잭션, 큐, 사용자 관리를 위한 Admin API 엔드포인트 구현",
        "jiraKey": "BFS-10",
        "details": "트랜잭션 관리 API (GET /admin/transactions, GET /admin/transactions/:id, POST /admin/transactions/:id/retry, PUT /admin/transactions/:id/status), 큐 관리 API (GET /admin/queues, GET /admin/queues/:name/messages, POST /admin/queues/:name/purge), 사용자 관리 API (GET /admin/users, POST /admin/users, PUT /admin/users/:id, DELETE /admin/users/:id), 시스템 통계 및 분석 API (GET /admin/stats, GET /admin/analytics, GET /admin/health), 검색/필터링/페이징 기능, 감사 로그 기록",
        "testStrategy": "각 Admin API 엔드포인트 기능 테스트, 권한 검증 테스트, 검색/필터링 정확성 테스트, 페이징 동작 테스트, 감사 로그 기록 테스트",
        "priority": "medium",
        "dependencies": [
          16
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "[BFS-11] Admin UI React 애플리케이션 구현",
        "description": "관리자를 위한 React 기반 웹 인터페이스 구현",
        "jiraKey": "BFS-11",
        "details": "Nx를 사용하여 React 앱 생성 (nx add @nx/react, nx g @nx/react:app admin-ui), Ant Design + Tailwind CSS를 활용한 UI 컴포넌트, TanStack Query(서버 상태) + Zustand(클라이언트 상태) 상태 관리, 실시간 대시보드 (트랜잭션 통계, 시스템 상태), 트랜잭션 관리 페이지 (검색/필터, 상태 추적, 수동 재시도), 큐 모니터링 페이지, 사용자 관리 페이지, Recharts를 사용한 데이터 시각화, 반응형 디자인 구현",
        "testStrategy": "각 페이지 렌더링 테스트, 사용자 상호작용 테스트, 실시간 데이터 업데이트 테스트, 반응형 디자인 테스트, 접근성(a11y) 테스트",
        "priority": "medium",
        "dependencies": [
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "[BFS-12] WebSocket 실시간 통신 시스템 구현",
        "description": "Admin UI와 백엔드 간 실시간 데이터 업데이트를 위한 WebSocket 통신 구현",
        "jiraKey": "BFS-12",
        "details": "Socket.IO를 사용한 WebSocket 서버 구현, 클라이언트-서버 이벤트 정의 (queue:update, transaction:update, system:alert), 구독/구독 취소 메커니즘, 실시간 큐 상태 모니터링, 트랜잭션 상태 변경 실시간 알림, 시스템 알림 브로드캐스트, 연결 상태 관리 및 재연결 로직, JWT 토큰 기반 WebSocket 인증",
        "testStrategy": "WebSocket 연결/해제 테스트, 실시간 이벤트 전송/수신 테스트, 구독/구독 취소 테스트, 재연결 로직 테스트, 인증된 WebSocket 연결 테스트",
        "priority": "low",
        "dependencies": [
          18
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "[BFS-13] Prometheus 메트릭 및 모니터링 시스템 구현",
        "description": "시스템 모니터링 및 알림을 위한 Prometheus 메트릭 수집 및 Grafana 대시보드 구축",
        "jiraKey": "BFS-13",
        "details": "prom-client를 사용한 Prometheus 메트릭 수집, 애플리케이션 메트릭 정의 (api_request_duration_seconds, queue_message_count, transaction_total), 시스템 메트릭 수집 (CPU, 메모리, 디스크 사용률), Grafana 대시보드 구성, 알림 임계값 설정 (API 오류율 > 5%, 큐 메시지 > 1000개), AlertManager 연동, 이메일/Slack 알림 설정, 메트릭 보존 정책 설정",
        "testStrategy": "메트릭 수집 정확성 테스트, 알림 트리거 테스트, Grafana 대시보드 시각화 테스트, 임계값 기반 알림 테스트, 메트릭 데이터 보존 테스트",
        "priority": "low",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "[BFS-31] 영구 연결을 위한 자동 재연결 로직 구현",
        "description": "Redis, 블록체인 노드 등의 영구 연결이 끊어졌을 때 자동으로 재연결을 시도하는 복원력 있는 연결 관리 시스템을 구현합니다.",
        "status": "pending",
        "dependencies": [
          15,
          20
        ],
        "priority": "medium",
        "details": "연결 관리를 위한 ConnectionManager 클래스 구현 (재연결 로직, 연결 상태 추적, 이벤트 발생), Redis 재연결 로직 구현 (ioredis의 reconnectOnError 활용, 지수 백오프 재시도 전략, 최대 재시도 횟수 제한), 블록체인 노드 재연결 구현 (Ethers.js의 WebSocketProvider 재연결 처리, 폴백 RPC 엔드포인트 설정, 연결 상태 모니터링), 재연결 전략 설정 (초기 재시도 간격: 1초, 최대 재시도 간격: 30초, 지수 백오프 계수: 2, 최대 재시도 횟수: 10회), 연결 상태 이벤트 (connected, disconnected, reconnecting, reconnected, error), 헬스체크 엔드포인트에 연결 상태 포함, 연결 실패 시 graceful degradation 처리, 연결 복구 시 대기 중인 작업 재개 로직, 연결 상태 메트릭 수집 (Prometheus)",
        "testStrategy": "Redis 연결 끊김 및 자동 재연결 테스트, 블록체인 노드 연결 실패 시나리오 테스트, 지수 백오프 재시도 간격 검증, 최대 재시도 횟수 도달 시 동작 테스트, 동시 다중 연결 재연결 테스트, 연결 복구 후 대기 작업 처리 테스트, 헬스체크 연결 상태 반영 테스트, 메트릭 수집 정확성 테스트",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "[BFS-32] Implement Hardhat node-based localhost chain support",
        "description": "Implement localhost blockchain network support based on Hardhat node for local development and testing environment. This enables fast and reliable development environment without external testnet dependencies. Ready to proceed sequentially starting from the first subtask.",
        "status": "in-progress",
        "dependencies": [],
        "priority": "medium",
        "details": "Hardhat development environment setup (npm install --save-dev hardhat @nomicfoundation/hardhat-ethers ethers, npx hardhat init for basic project structure, hardhat.config.ts configuration file setup), Local network configuration (defaultNetwork: 'hardhat', networks.hardhat settings - chainId: 31337, mining.auto: true, mining.interval: 3000ms, accounts configuration - including LocalStack private key 0x0000000000000000000000000000000000000000000000000000000000000001), Environment variable-based network switching (POLYGON_NETWORK=localhost support, LOCALHOST_RPC_URL=http://127.0.0.1:8545 configuration, localhost option addition alongside existing amoy/mainnet), NetworkConfig type extension (localhost network configuration addition, chainId: 31337, name: 'localhost', rpcUrl setting), Smart contract deployment scripts (scripts/deploy-localhost.ts implementation, ERC20 token contract deployment, Multicall3 contract deployment, transfer all test tokens to signing address, export deployed addresses as environment variables), Local development workflow improvement (integrate hardhat service into existing docker-compose, run npx hardhat node --hostname 0.0.0.0, automatic account creation and funding, block mining interval configuration), Test helper utility implementation (test account creation functions, test token transfer functions, block timestamp manipulation functions, snapshot/revert functionality), Developer tools integration (utilize Hardhat Network Helper, console.log debugging support, gas reporting configuration, solidity coverage measurement), Fork mode support (polygon mainnet/testnet fork functionality, fork from specific block height, simulate real network state), Automation scripts (add npm run dev:localhost command, sequential execution: start Hardhat node → deploy contracts → setup test data → start API server). Now ready to start from the first subtask (22.1).",
        "testStrategy": "Hardhat node connection test (localhost RPC connection verification, chain ID 31337 validation), Test account operation verification (confirm signing address 0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf created with LocalStack private key, verify ETH and token balances of signing address), ERC20 token deployment and transfer test (confirm successful token contract deployment, verify all tokens transferred to signing address, test token transfer transactions, validate balance query accuracy), Multicall3 contract test (verify batch call functionality, test multi-token balance queries), Block mining operation test (verify automatic mining interval, test manual mining trigger), Transaction processing flow test (complete flow: withdrawal request → queue → processing → monitoring, gas estimation on local network, transaction receipt queries), Fork mode test (mainnet fork state verification, test interactions with real contracts), Development environment integration test (execute full stack with docker-compose up, verify automatic deployment script operation, API server and local blockchain integration), Performance comparison test (compare local vs testnet transaction speeds, measure development workflow efficiency)",
        "subtasks": [
          {
            "id": 1,
            "title": "Hardhat development environment setup and project initialization",
            "description": "Install Hardhat packages and configure basic project structure with TypeScript-based configuration files. [Updated: 2025. 7. 23.] [Updated: 2025. 7. 23.]",
            "status": "in-progress",
            "dependencies": [],
            "details": "Execute npm install --save-dev hardhat @nomicfoundation/hardhat-ethers ethers @typechain/hardhat typechain @typechain/ethers-v6, create TypeScript project with npx hardhat init, generate hardhat.config.ts file with basic configuration, setup contracts/, scripts/, test/ directory structure, add artifacts/, cache/, typechain-types/ to .gitignore, add Hardhat type references to tsconfig.json\n<info added on 2025-07-23T13:07:54.480Z>\ndocker/hardhat directory structure creation: create docker/hardhat/ folder with package.json (including hardhat, @nomicfoundation/hardhat-ethers, ethers, @typechain/hardhat, typechain dependencies), hardhat.config.js (network settings - localhost:8545, chainId:31337, account configuration), Dockerfile and docker-compose.yml service definition for running Hardhat node in Docker environment, setup to run local blockchain network with hardhat node command inside container\n</info added on 2025-07-23T13:07:54.480Z>\n<info added on 2025-07-23T13:16:15.109Z>\nJira key mapping added to BFS-33 - indicates this subtask is linked to Jira issue BFS-33\n</info added on 2025-07-23T13:16:15.109Z>\n<start-ready on 2025-07-23T13:30:00.000Z>\nReady to start immediately: Begin with the first subtask of installing Hardhat packages and initial setup. Includes docker/hardhat directory structure creation and Hardhat node execution environment setup.\n</start-ready on 2025-07-23T13:30:00.000Z>\n<info added on 2025-07-23T14:46:20.347Z>\n작업 제목과 설명 영어 번역 완료:\n\nTitle: \"Hardhat development environment setup and project initialization\"\nDescription: \"Install Hardhat packages and configure basic project structure with TypeScript-based configuration files.\"\n\n영어 번역본이 이미 기존 작업 내용에 반영되어 있으며, 해당 작업은 Hardhat 개발 환경 설정 및 프로젝트 초기화를 수행하는 첫 번째 서브태스크입니다.\n</info added on 2025-07-23T14:46:20.347Z>",
            "testStrategy": "Verify Hardhat installation (npx hardhat --version), validate project structure, confirm successful TypeScript compilation, test hardhat compile command execution, test Hardhat node execution in Docker environment"
          },
          {
            "id": 2,
            "title": "Local network configuration and environment variable setup",
            "description": "Configure Hardhat local network and setup environment variables including LocalStack private key.",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Add networks.hardhat configuration to hardhat.config.ts (chainId: 31337, mining.auto: true, mining.interval: 3000, accounts configuration - including LocalStack private key 0x0000000000000000000000000000000000000000000000000000000000000001 to generate signing address 0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf), add POLYGON_NETWORK=localhost option to .env file, set LOCALHOST_RPC_URL=http://127.0.0.1:8545, add LOCALHOST_SIGNING_PRIVATE_KEY=0x0000000000000000000000000000000000000000000000000000000000000001, add localhost network to NetworkConfig type in packages/shared/src/config/network.config.ts, add localhost case to getNetworkConfig function, integrate hardhat service into existing docker-compose.yaml (run npx hardhat node --hostname 0.0.0.0)\n<info added on 2025-07-23T13:08:14.414Z>\nAdd localhost chain configuration to chains.config.json (chainId: 31337, name: 'Localhost', symbol: 'ETH', decimals: 18, rpcUrl: 'http://127.0.0.1:8545'), add 'localhost' to ChainName type in packages/shared/src/types/chain.types.ts, add localhost case handling in packages/shared/src/providers/chain-provider.factory.ts (create JsonRpcProvider instance)\n</info added on 2025-07-23T13:08:14.414Z>",
            "testStrategy": "Test local network connection (verify RPC endpoint response), validate chainId 31337, confirm signing address created with LocalStack private key, test environment variable loading, verify localhost configuration returned from NetworkConfig"
          },
          {
            "id": 3,
            "title": "ERC20 token and Multicall3 contract deployment script implementation",
            "description": "Implement scripts to deploy test ERC20 tokens and Multicall3 contract, transferring all tokens to the signing address.",
            "status": "pending",
            "dependencies": [
              2
            ],
            "details": "Create contracts/TestToken.sol (inherit OpenZeppelin ERC20, include minting function), add contracts/Multicall3.sol (for batch calls), write scripts/deploy-localhost.ts deployment script, deploy ERC20 token and transfer all tokens (e.g., 1,000,000 TEST) to signing address 0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf, deploy Multicall3 contract, save deployed contract addresses to .env.localhost file (TEST_TOKEN_ADDRESS, MULTICALL3_ADDRESS), create scripts/setup-test-data.ts for test data setup (user creation, sample withdrawal requests, etc.), automate type generation with TypeChain\n<info added on 2025-07-23T13:08:36.235Z>\nCreate contracts/Multicall3.sol file using provided Multicall3.sol code, create contracts/TestToken.sol file (inherit OpenZeppelin ERC20 with minting functionality), write scripts/deploy.js deployment script (deploy both contracts and transfer all tokens to signing address 0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf), save deployment information to deployment.json file (instead of or in addition to existing .env.localhost)\n</info added on 2025-07-23T13:08:36.235Z>",
            "testStrategy": "Verify successful contract compilation, test deployment script execution, confirm all tokens transferred to signing address, test Multicall3 batch call functionality, verify contract addresses saved to environment variables"
          },
          {
            "id": 4,
            "title": "Test helper utilities and developer tools implementation",
            "description": "Implement helper functions for efficient testing on Hardhat network and integrate developer tools.",
            "status": "pending",
            "dependencies": [
              3
            ],
            "details": "Create packages/shared/src/utils/hardhat-helpers.ts (getSigningAccount, fundAccount, advanceTime, takeSnapshot/revertToSnapshot functions, Multicall3 interface functions), integrate Hardhat Network Helpers (@nomicfoundation/hardhat-network-helpers), setup console.log debugging support, configure hardhat-gas-reporter plugin, setup solidity-coverage plugin, add Fork mode support (forking configuration in hardhat.config.ts), add signing address related helper functions\n<info added on 2025-07-23T13:08:56.753Z>\nImplement init-hardhat.sh script: Hardhat node waiting logic (check http://127.0.0.1:8545 status with curl, wait up to 30 seconds), contract compilation (execute npx hardhat compile), deployment script execution (node scripts/deploy.js), integration with hardhat-deploy service in docker-compose.yaml (set depends_on to run after hardhat-node is ready, dependency management through healthcheck), script execution permissions (chmod +x init-hardhat.sh), error handling and logging (output success/failure logs for each step)\n</info added on 2025-07-23T13:08:56.753Z>",
            "testStrategy": "Unit test helper functions, test signing address query functions, verify snapshot/revert functionality operation, validate time manipulation function accuracy, confirm gas reporting output, test Multicall3 helper functions"
          },
          {
            "id": 5,
            "title": "Automation scripts and development workflow integration",
            "description": "Create automation scripts for local development environment and fully integrate with existing Docker Compose system.",
            "status": "pending",
            "dependencies": [
              4
            ],
            "details": "Add dev:localhost script to package.json (sequential execution: start Hardhat node → deploy contracts → setup test data → start API server), write scripts/start-local-dev.sh shell script, modify all microservices to recognize localhost network and signing address, update blockchain connection logic in withdrawal-api, tx-processor, tx-monitor services to use LocalStack private key, fully integrate hardhat service into existing docker-compose.yaml file, add dependency management with LocalStack, update README.md with local development guide (including LocalStack private key, signing address, Multicall3 usage)\n<info added on 2025-07-23T13:09:21.263Z>\nAdd hardhat-node and hardhat-deploy service configuration to docker-compose.yaml file (hardhat-node: use hardhat/hardhat:latest image, port mapping 8545:8545, chain-id 31337 setting; hardhat-deploy: dedicated service for contract deployment, hardhat-node dependency setting), add CHAIN_NAME=localhost environment variable support (add localhost chain identifier alongside existing amoy/mainnet, LOCALHOST_RPC_URL=http://hardhat-node:8545 internal network connection), update all microservices (withdrawal-api, tx-processor, tx-monitor) environment variables to recognize localhost chain, set Multicall3 contract address for localhost chain (0xcA11bde05977b3631167028862bE2a173976CA11 standard address or deployed address), manage inter-service network dependencies (sequential start: hardhat-node → hardhat-deploy → api services), healthcheck configuration to verify service readiness\n</info added on 2025-07-23T13:09:21.263Z>",
            "testStrategy": "Test complete local development environment startup, verify Docker Compose integration, validate inter-service communication, test complete flow using signing address: withdrawal request → processing → monitoring, test batch queries using Multicall3, test automatic restart and state recovery"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-21T09:59:36.904Z",
      "updated": "2025-07-23T14:21:04.102Z",
      "description": "Tasks for master context"
    }
  }
}