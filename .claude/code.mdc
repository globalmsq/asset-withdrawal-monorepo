# code.mdc - Code Quality and Analysis Guidelines

## Code Style Guidelines

### TypeScript Requirements
- Use TypeScript strictly - ensure all types are properly defined
- Follow existing patterns in the codebase
- Keep functions small and focused (single responsibility)
- Use async/await consistently for asynchronous operations
- Define interfaces for all data structures
- Avoid `any` type - use proper typing or `unknown` when necessary

### API Development
- Follow RESTful conventions for endpoints
- Always validate request data using existing validators in `packages/shared/src/validators`
- Return consistent response formats using existing response utilities
- Include proper error handling with appropriate HTTP status codes

### Error Handling
- Use custom error classes from `packages/shared/src/errors`
- Always catch and handle errors appropriately
- Log errors with sufficient context for debugging
- Never expose sensitive information in error messages

## Testing Strategy

### Initial Test Creation
When creating new features, initially create minimal test files with a single passing test:
```typescript
describe('FeatureName', () => {
  it('should exist', () => {
    expect(true).toBe(true);
  });
});
```

### Comprehensive Testing (When Requested)
Only implement comprehensive tests when explicitly requested:
- Test both success and error cases
- Mock external dependencies (database, blockchain services, SQS)
- Use Jest and Supertest for API endpoints
- Aim for >80% code coverage on critical paths
- Include edge cases and boundary conditions

## Quality Checks

### Mandatory Checks
**MUST RUN** after any code modification:
```bash
pnpm run lint        # Check code style
pnpm run typecheck   # Check TypeScript types
```

### Optional Checks
Run only when explicitly requested:
```bash
npm test             # Run all tests
npm run test:coverage # Check test coverage
```

## Security Best Practices

### Authentication & Authorization
- Use JWT tokens for authentication (already configured)
- Check user permissions before performing sensitive operations
- Implement role-based access control where necessary

### Data Security
- Never expose sensitive information in logs or responses
- Always hash passwords using bcrypt before storing
- Validate all user inputs thoroughly
- Sanitize data before database operations
- Use parameterized queries (Prisma handles this)

### Blockchain Security
- Validate all addresses using checksum validation
- Never log private keys or mnemonics
- Use secure random number generation for nonces
- Implement gas price limits and validation

## Database Guidelines

### Prisma Usage
- Always use Prisma for database queries - never write raw SQL
- Use transactions for operations that modify multiple records
- Handle database errors gracefully with proper error messages
- Use proper indexing for frequently queried fields

### Migration Rules
- **NO MIGRATION GENERATION**: Do not create Prisma migration files
- Schema changes should be documented in plan.md only
- Migration files will be created only when explicitly requested
- Use existing schema for development

### Data Integrity
- Use database constraints where appropriate
- Implement soft deletes for critical data
- Maintain audit trails for sensitive operations
- Use optimistic locking for concurrent updates

## Performance Considerations

### Code Optimization
- Avoid N+1 query problems - use Prisma's include/select
- Implement pagination for large datasets
- Use caching where appropriate (Redis)
- Batch operations when possible

### Async Operations
- Use Promise.all() for parallel operations
- Implement proper timeout handling
- Use queues for long-running operations
- Handle backpressure in stream processing

## Microservices Architecture

### Service Communication
- Use queues (SQS) for async communication
- Implement proper retry logic with exponential backoff
- Handle partial failures gracefully
- Maintain service independence

### App Naming Convention
Apps should be named based on their primary function:
- `{action}-{target}`: e.g., `withdrawal-api`, `tx-processor`
- Avoid generic names like `api-server` or `worker`
- Each app should have a single, well-defined responsibility

## Documentation Standards

### Code Comments
- Keep inline comments minimal - code should be self-explanatory
- Document complex business logic
- Include JSDoc for public APIs
- Document any workarounds or technical debt

### API Documentation
- Update API documentation if you modify endpoints
- Include request/response examples
- Document error responses
- Keep Swagger/OpenAPI specs up to date